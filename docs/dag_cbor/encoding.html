<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dag_cbor.encoding API documentation</title>
<meta name="description" content="Encoding functions for DAG-CBOR codec …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dag_cbor.encoding</code></h1>
</header>
<section id="section-intro">
<p>Encoding functions for DAG-CBOR codec.</p>
<p>The core functionality is performed by the <code><a title="dag_cbor.encoding.encode" href="#dag_cbor.encoding.encode">encode()</a></code> function, which encods a value into a <code>bytes</code> object:</p>
<pre><code class="language-python">    &gt;&gt;&gt; import dag_cbor
    &gt;&gt;&gt; dag_cbor.encode({'a': 12, 'b': 'hello!'})
    b'¢aaabfhello!'
</code></pre>
<p>A buffered binary stream (i.e. an instance of <code>io.BufferedIOBase</code>) can be passed to the <code><a title="dag_cbor.encoding.encode" href="#dag_cbor.encoding.encode">encode()</a></code> function
using the optional keyword argument <code>stream</code>, in which case the encoded bytes are written to the stream
and the number of bytes written is returned:</p>
<pre><code class="language-python">    &gt;&gt;&gt; from io import BytesIO
    &gt;&gt;&gt; mystream = BytesIO()
    &gt;&gt;&gt; dag_cbor.encode({'a': 12, 'b': 'hello!'}, stream=mystream)
    13
    &gt;&gt;&gt; mystream.getvalue()
    b'¢aaabfhello!'
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Encoding functions for DAG-CBOR codec.

    The core functionality is performed by the `encode` function, which encods a value into a `bytes` object:

    ```python
        &gt;&gt;&gt; import dag_cbor
        &gt;&gt;&gt; dag_cbor.encode({&#39;a&#39;: 12, &#39;b&#39;: &#39;hello!&#39;})
        b&#39;\xa2aa\x0cabfhello!&#39;
    ```

    A buffered binary stream (i.e. an instance of `io.BufferedIOBase`) can be passed to the `encode` function
    using the optional keyword argument `stream`, in which case the encoded bytes are written to the stream
    and the number of bytes written is returned:

    ```python
        &gt;&gt;&gt; from io import BytesIO
        &gt;&gt;&gt; mystream = BytesIO()
        &gt;&gt;&gt; dag_cbor.encode({&#39;a&#39;: 12, &#39;b&#39;: &#39;hello!&#39;}, stream=mystream)
        13
        &gt;&gt;&gt; mystream.getvalue()
        b&#39;\xa2aa\x0cabfhello!&#39;
    ```

&#34;&#34;&#34;

from io import BufferedIOBase, BytesIO
import math
import struct
from typing import Optional, overload, Union

import cid # type: ignore

from .utils import CBOREncodingError, DAGCBOREncodingError, _check_key_compliance

EncodableType = Union[None, bool, int, bytes, str, list, dict, cid.cid.BaseCID, float]

@overload
def encode(data: EncodableType, stream: None = None) -&gt; bytes:
    ... # pragma: no cover

@overload
def encode(data: EncodableType, stream: BufferedIOBase) -&gt; int:
    ... # pragma: no cover

def encode(data: EncodableType, stream: Optional[BufferedIOBase] = None) -&gt; Union[bytes, int]:
    &#34;&#34;&#34;
        Encodes the given `data` with the DAG-CBOR codec.
        If a `stream` is given, the encoded data is written to the stream and the number of bytes written is returned.
        Otherwise, the encoded data is written to an internal stream and the bytes are returned at the end (as a `bytes` object).
    &#34;&#34;&#34;
    if stream is None:
        internal_stream = BytesIO()
        _encode(internal_stream, data)
        return internal_stream.getvalue()
    return _encode(stream, data)

def _encode(stream: BufferedIOBase, value: EncodableType) -&gt; int:
    # pylint: disable = too-many-return-statements, too-many-branches
    if isinstance(value, bool): # must go before int check
        # major type 0x7 (additional info 20 and 21)
        return _encode_bool(stream, value)
    if isinstance(value, int):
        # major types 0x0 and 0x1
        return _encode_int(stream, value)
    if isinstance(value, bytes):
        # major type 0x2
        return _encode_bytes(stream, value)
    if isinstance(value, str):
        # major type 0x3
        return _encode_str(stream, value)
    if isinstance(value, list):
        # major type 0x4
        return _encode_list(stream, value)
    if isinstance(value, dict):
        # major type 0x5
        return _encode_dict(stream, value)
    if isinstance(value, cid.cid.BaseCID):
        # major type 0x6
        return _encode_cid(stream, value)
    if value is None:
        # major type 0x7 (additional info 22)
        return _encode_none(stream, value)
    if isinstance(value, float):
        # major type 0x7 (additional info 27)
        return _encode_float(stream, value)
    raise DAGCBOREncodingError(f&#34;Type {type(value)} is not encodable.&#34;)

def _encode_head(stream: BufferedIOBase, major_type: int, arg: int) -&gt; int:
    if arg &lt; 24:
        # argument value as additional info in leading byte
        head = struct.pack(&#34;&gt;B&#34;, (major_type&lt;&lt;5)|arg)
    elif arg &lt;= 255:
        # leading byte + 1 byte argument value (additional info = 24)
        head = struct.pack(&#34;&gt;BB&#34;, (major_type&lt;&lt;5)|24, arg)
    elif arg &lt;= 65535:
        # leading byte + 2 bytes argument value (additional info = 25)
        head = struct.pack(&#34;&gt;BH&#34;, (major_type&lt;&lt;5)|25, arg)
    elif arg &lt;= 4294967295:
        # leading byte + 4 bytes argument value (additional info = 26)
        head = struct.pack(&#34;&gt;BL&#34;, (major_type&lt;&lt;5)|26, arg)
    else:
        # leading byte + 8 bytes argument value (additional info = 27)
        head = struct.pack(&#34;&gt;BQ&#34;, (major_type&lt;&lt;5)|27, arg)
    stream.write(head)
    return len(head)

def _encode_int(stream: BufferedIOBase, value: int) -&gt; int:
    if value &gt;= 18446744073709551616:
        # unsigned int must be &lt; 2**64
        raise CBOREncodingError(&#34;Unsigned integer out of range.&#34;)
    if value &lt; -18446744073709551616:
        # negative int must be &gt;= -2**64
        raise CBOREncodingError(&#34;Negative integer out of range.&#34;)
    if value &gt;= 0:
        # unsigned int
        return _encode_head(stream, 0x0, value)
    # negative int
    return _encode_head(stream, 0x1, -1-value)

def _encode_bytes(stream: BufferedIOBase, value: bytes) -&gt; int:
    num_head_bytes = _encode_head(stream, 0x2, len(value))
    stream.write(value)
    return num_head_bytes+len(value)

def _encode_str(stream: BufferedIOBase, value: str) -&gt; int:
    try:
        utf8_value: bytes = value.encode(&#34;utf-8&#34;, errors=&#34;strict&#34;)
    except UnicodeError as e:
        raise CBOREncodingError(&#34;Strings must be valid utf-8 strings.&#34;) from e
    num_head_bytes = _encode_head(stream, 0x3, len(utf8_value))
    stream.write(utf8_value)
    return num_head_bytes+len(utf8_value)

def _encode_list(stream: BufferedIOBase, value: list) -&gt; int:
    num_bytes_written = _encode_head(stream, 0x4, len(value))
    for item in value:
        num_bytes_written += _encode(stream, item)
    return num_bytes_written

def _encode_dict(stream: BufferedIOBase, value: dict) -&gt; int:
    _check_key_compliance(value)
    # sort keys canonically
    try:
        utf8key_val_pairs = [(k.encode(&#34;utf-8&#34;, errors=&#34;strict&#34;), v)
                             for k, v in value.items()]
    except UnicodeError as e:
        raise CBOREncodingError(&#34;Strings must be valid utf-8 strings.&#34;) from e
    sorted_utf8key_val_pairs = sorted(utf8key_val_pairs, key=lambda i: i[0])
    # encode key-value pairs (keys already utf-8 encoded)
    num_bytes_written = _encode_head(stream, 0x5, len(value))
    for utf8k, v in sorted_utf8key_val_pairs:
        num_bytes_written += _encode_head(stream, 0x3, len(utf8k))
        stream.write(utf8k)
        num_bytes_written += len(utf8k)
        num_bytes_written += _encode(stream, v)
    return num_bytes_written

def _encode_cid(stream: BufferedIOBase, value: cid.cid.BaseCID) -&gt; int:
    num_bytes_written = _encode_head(stream, 0x6, 42)
    num_bytes_written += _encode_bytes(stream, value.buffer)
    return num_bytes_written

def _encode_bool(stream: BufferedIOBase, value: bool) -&gt; int:
    return _encode_head(stream, 0x7, 21 if value else 20)

def _encode_none(stream: BufferedIOBase, value: None) -&gt; int:
    return _encode_head(stream, 0x7, 22)

def _encode_float(stream: BufferedIOBase, value: float) -&gt; int:
    if math.isnan(value):
        raise DAGCBOREncodingError(&#34;NaN is not an allowed float value.&#34;)
    if math.isinf(value):
        if value &gt; 0:
            raise DAGCBOREncodingError(&#34;Infinity is not an allowed float value.&#34;)
        raise DAGCBOREncodingError(&#34;-Infinity is not an allowed float value.&#34;)
    # special head, with double encoding for 4B argument value
    head = struct.pack(&#34;&gt;Bd&#34;, (0x7&lt;&lt;5)|27, value)
    stream.write(head)
    return len(head)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dag_cbor.encoding.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>data: Union[ForwardRef(None), bool, int, bytes, str, list, dict, cid.cid.BaseCID, float], stream: Optional[io.BufferedIOBase] = None) ‑> Union[bytes, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the given <code>data</code> with the DAG-CBOR codec.
If a <code>stream</code> is given, the encoded data is written to the stream and the number of bytes written is returned.
Otherwise, the encoded data is written to an internal stream and the bytes are returned at the end (as a <code>bytes</code> object).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(data: EncodableType, stream: Optional[BufferedIOBase] = None) -&gt; Union[bytes, int]:
    &#34;&#34;&#34;
        Encodes the given `data` with the DAG-CBOR codec.
        If a `stream` is given, the encoded data is written to the stream and the number of bytes written is returned.
        Otherwise, the encoded data is written to an internal stream and the bytes are returned at the end (as a `bytes` object).
    &#34;&#34;&#34;
    if stream is None:
        internal_stream = BytesIO()
        _encode(internal_stream, data)
        return internal_stream.getvalue()
    return _encode(stream, data)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dag_cbor" href="index.html">dag_cbor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dag_cbor.encoding.encode" href="#dag_cbor.encoding.encode">encode</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>